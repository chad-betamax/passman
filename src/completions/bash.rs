use std::fs::OpenOptions;
use std::io::{BufRead, BufReader, Write};

/// Appends file-based wrapper logic to passman.bash
pub fn install_file_path_completion() -> anyhow::Result<()> {
    let config_dir = dirs::config_dir().expect("Could not determine config dir");
    let bash_dir = config_dir.join("bash/completions");
    let passman_bash = bash_dir.join("passman.bash");

    if !passman_bash.exists() {
        anyhow::bail!(
            "Expected {} to exist (generated by clap)",
            passman_bash.display()
        );
    }

    // Check if wrapper is already present
    let already_done = {
        let f = std::fs::File::open(&passman_bash)?;
        BufReader::new(f)
            .lines()
            .any(|line| line.map_or(false, |l| l.contains("_passman_wrapper")))
    };

    if !already_done {
        // Open for appending
        let mut f = OpenOptions::new()
            .write(true)
            .append(true)
            .open(&passman_bash)?;

        let wrapper = r#"
# === Passman custom wrapper for file-based completions ===
_passman_wrapper() {
    local subcommand cur
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    subcommand="${COMP_WORDS[1]}"

    if [[ "$subcommand" == "list" || "$subcommand" == "show" ]]; then
        local files
        files=$(find ~/.passman/vault -type f -name '*.rage' 2>/dev/null | sed 's|.rage$||;s|^.*vault/||')
        COMPREPLY=( $(compgen -W "${files}" -- "$cur") )
    else
        _passman "$@"
    fi
}

# Override default handler
complete -F _passman_wrapper passman
"#;

        f.write_all(wrapper.as_bytes())?;
    }

    Ok(())
}
